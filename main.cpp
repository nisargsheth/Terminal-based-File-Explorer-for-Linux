#include <bits/stdc++.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <ctype.h>
#include<sys/types.h>
#include <sys/select.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include<sys/wait.h> 
#include <cmath>
#include<fcntl.h>
#include <time.h>
using namespace std;

struct termios oldattr, newattr;
bool goto_flag = false;
void delay(int number_of_seconds){
    int milli_seconds = 1000 * number_of_seconds; 
    clock_t start_time = clock(); 
  
    while (clock() < start_time + milli_seconds) 
        ; 
} 

void setold(){
    fflush(stdin);
    fflush(stdout);
    tcsetattr(0, TCSADRAIN, &oldattr);
}

void setnew(){
    // if(gotoflag) cout << endl << "setnew for goto" << endl;
    fflush(stdin);
    fflush(stdout);
    cin.get();
    newattr.c_lflag &= ~(ECHO | ICANON);
    //cin.get();
    // cout << "new mode status: " << tcsetattr (STDIN_FILENO, TCSADRAIN, &newattr) << endl;
    tcsetattr (STDIN_FILENO, TCSADRAIN, &newattr);
}

int getCursorPosition(int *rows, int *cols) {
    //https://web.archive.org/web/20151004211730/http://www.termsys.demon.co.uk/vtansi.htm
    // logic:
    // \033[6n queries the cursor position and the response is
    // generated on the termimal so we need to read the response after querying.
    // write(\033[6n) queries.
    // then we read the response.
    // response format :
    // /Report Cursor Position	<ESC>[{ROW};{COLUMN}R Generated by the device in response to a Query Cursor Position request; reports current cursor position.
    // so we read till R is read.
    // then we set the null character at the end of the string.
    // then we check if the response is correct
    // then we scan the third and 
  char buf[32];
  unsigned int i = 0;
  if (write(STDOUT_FILENO, "\x1b[6n", 4) != 4) return -1;
  while (i < sizeof(buf) - 1) {
    if (read(STDIN_FILENO, &buf[i], 1) != 1) break;
    if (buf[i] == 'R') break;
    i++;
  }
  buf[i] = '\0';
  if (buf[0] != '\x1b' || buf[1] != '[') return -1;
  //sscanf reads from the string.
  if (sscanf(&buf[2], "%d;%d", rows, cols) != 2) return -1;
  return 0;
}



vector<string> dir_arr;
vector<struct dirent*> dir_struct_arr;
stack<char*> st1;
stack<char*> st2;
int dir_cnt;
int cur_dir;
int cnt;
char* path;
char* home_path;
double max_size_len;
int sx, sy;
void control(){
    path = new char[PATH_MAX];
    getcwd(path,PATH_MAX);
    // st1.push(path);
    max_size_len = 0;
    dir_cnt = 0;
    cur_dir = 0;
    cnt = 0;
    dir_arr.clear();
    dir_struct_arr.clear();
    DIR* dir_ptr = opendir(".");
    struct dirent* dir_ent_ptr;
    if(!dir_ptr){
        fflush(stdout);
        cout << "Error opening directory" << endl;
        exit(0);
    }
    
    dir_ent_ptr = readdir(dir_ptr);
    while(dir_ent_ptr){
        //++dir_cnt;
        // cout << dir_ent_ptr->d_name << endl;
        dir_struct_arr.push_back(dir_ent_ptr);
        dir_arr.push_back(dir_ent_ptr->d_name);
        dir_ent_ptr = readdir(dir_ptr);
    }   
    dir_cnt = dir_arr.size();
    cur_dir = dir_cnt - 1;
    cnt = dir_cnt;
    closedir(dir_ptr);
    //navigate();
}

void print(){
    // for(auto it : dir_arr) cout << it << endl;
    struct stat filestat;
    // for(auto it : dir_struct_arr) cout << it->d_name << " " << it->d_off << endl;
    // stat(dir_struct_arr[cur_dir]->d_name,&filestat);


    
    for(auto it : dir_struct_arr){
        stat(it->d_name, &filestat);
        max_size_len = max(max_size_len, log10((filestat.st_size)/(1000.0)));
    }

    for(auto it : dir_struct_arr){
        // printf("%s\t",it->d_name);
        // cout << setw(256) << it->d_name;
        stat(it->d_name, &filestat);        
        fflush(stdout);
        cout << ((filestat.st_mode & S_IRUSR)? "r":"-");
        cout << ((filestat.st_mode & S_IWUSR)? "w":"-"); 
        cout << ((filestat.st_mode & S_IXUSR)? "x":"-");
        // printf((filestat.st_mode & S_IRUSR)? "r":"-");
        // printf((filestat.st_mode & S_IWUSR)? "w":"-");
        // printf((filestat.st_mode & S_IXUSR)? "x":"-");
        // printf("\n");
        // printf("\nFile Permissions Group\n");

        cout << ((filestat.st_mode & S_IRGRP)? "r":"-");
        cout << ((filestat.st_mode & S_IWGRP)? "w":"-");
        cout << ((filestat.st_mode & S_IXGRP)? "x":"-");
        // printf((filestat.st_mode & S_IRGRP)? "r":"-");
        // printf((filestat.st_mode & S_IWGRP)? "w":"-");
        // printf((filestat.st_mode & S_IXGRP)? "x":"-");
        // printf("\n");
        // printf("\nFile Permissions Other\n");


        cout << ((filestat.st_mode & S_IROTH)? "r":"-");
        cout << ((filestat.st_mode & S_IWOTH)? "w":"-");
        cout << ((filestat.st_mode & S_IXOTH)? "x":"-");
        // printf((filestat.st_mode & S_IROTH)? "r":"-");
        // printf((filestat.st_mode & S_IWOTH)? "w":"-");
        // printf((filestat.st_mode & S_IXOTH)? "x":"-");
        // printf("\t");


        if(filestat.st_size > 1000){
            // printf("%f KB\t",(filestat.st_size)/(1000.0));
            fflush(stdout);
            cout << setw(10) << (filestat.st_size)/(1000.0) << "KB";
            printf("\t");
        }
        else{
            fflush(stdout);
            cout << setw(10) << filestat.st_size << " B";
            printf("\t");
            // printf("%ld B\t",filestat.st_size);
        }

        



        string m_time = string(ctime(&filestat.st_mtime));
        m_time = m_time.substr(4, 12);
        fflush(stdout);
        cout << setw(8) << m_time << "  ";

        cout << it->d_name << endl;

    }


    printf("\033[1A");
}

int run(){
    pid_t child_pid;
    int child_status;

    child_pid = fork();
    pid_t tpid;
    if(child_pid==0){
        char *args[]={"/usr/bin/vi",dir_struct_arr[cur_dir]->d_name,NULL}; 
        execv(args[0], args);
        printf("Error occured..!");
        exit(0);

    }
    else{
        do{
            tpid = wait(&child_status);
            
        }while(tpid!=child_pid);

        return child_status;
    }
}


void parse_cmd(string str, vector<string> &parsed){
    parsed.clear();
    string tmp = "";
    for(auto it : str){
        if(it==' '){
            parsed.push_back(tmp);
            tmp = "";
        }
        else{
            tmp.push_back(it);
        }
    }
    parsed.push_back(tmp);
}



void create_file(string filename, string dest_path){
    string path = dest_path + "/" + filename;
    open(path.c_str(), O_CREAT|O_TRUNC|O_RDWR, 0777);
}


void create_dir(string pathname){
    // string pathname = dest_path + "/" + dirname;
    mkdir(pathname.c_str(), 0777);

    struct stat filestats;

    stat(pathname.c_str(),&filestats);
    // cout << pathname << "ISDIR: " << S_ISDIR(filestats.st_mode) << endl;

}


void copy_file(string source, string destpath){
    FILE* srcf=NULL;
    FILE* destf=NULL;
    destf = fopen(destpath.c_str(),"w");   
    if(!destf){
        cout << "error opening file " << destpath.c_str() <<endl;
        exit(0);
    }
    srcf = fopen(source.c_str(),"r");
    if(!srcf){
        cout << "error opening file " << source.c_str() << endl;
        exit(0);
    }
    char c;
    c = fgetc(srcf); 
    while (c != EOF){
        fputc(c, destf); 
        c = fgetc(srcf); 
    } 
    fclose(srcf);
    fclose(destf);
}

void copy_dir(string path, string dest_path){
    DIR* dir_ptr = opendir(path.c_str());
    struct dirent* dir_ent_ptr;

    dir_ent_ptr = readdir(dir_ptr);

    struct stat filestats;

    while(dir_ent_ptr){
        // cout << "currfile: " << dir_ent_ptr->d_name << endl;
        if(string(dir_ent_ptr->d_name)=="." || string(dir_ent_ptr->d_name)==".."){
            dir_ent_ptr = readdir(dir_ptr);
            continue;
        } 
        string next_source = path + "/" + dir_ent_ptr->d_name;
        string next_dest = dest_path + "/" + dir_ent_ptr->d_name;
        stat(next_source.c_str(), &filestats);

        if(S_ISDIR(filestats.st_mode)){
            // cout << "ISDIR YES" << endl;
            create_dir(next_dest);
            copy_dir(next_source, next_dest);
        }
        else{
            // cout << "Curr file : " << dir_ent_ptr->d_name << ": ";
            // cout <<" ISDIR NO " << endl;
            copy_file(next_source, next_dest);
        }
        dir_ent_ptr = readdir(dir_ptr);
    }
    closedir(dir_ptr);
}

void delete_dir(string path){
    DIR* dir_ptr = opendir(path.c_str());
    struct dirent* dir_ent_ptr;

    dir_ent_ptr = readdir(dir_ptr);

    struct stat filestats;

    while(dir_ent_ptr){
        // cout << "currfile: " << dir_ent_ptr->d_name << endl;
        if(string(dir_ent_ptr->d_name)=="." || string(dir_ent_ptr->d_name)==".."){
            dir_ent_ptr = readdir(dir_ptr);
            continue;
        } 
        string next_source = path + "/" + dir_ent_ptr->d_name;
        // string next_dest = dest_path + "/" + dir_ent_ptr->d_name;
        stat(next_source.c_str(), &filestats);

        if(S_ISDIR(filestats.st_mode)){
            // cout << "ISDIR YES" << endl;
            // create_dir(next_dest);
            // copy_dir(next_source, next_dest);
            delete_dir(next_source);
            // rmdir(path.c_str());
        }
        else{
            // cout << "Curr file : " << dir_ent_ptr->d_name << ": ";
            // cout <<" ISDIR NO " << endl;
            // copy_file(next_source, next_dest);
            remove(next_source.c_str());
        }
        dir_ent_ptr = readdir(dir_ptr);
    }
    rmdir(path.c_str());
    closedir(dir_ptr);
}

void remove_empty(string path){
    cout << "success: " << rmdir(path.c_str()) << endl;
}

void move_dir(string path, string dest_path){
    create_dir(dest_path);
    copy_dir(path, dest_path);
    delete_dir(path);
}

void go_to(string to_path){
    getcwd(path, PATH_MAX);
    st1.push(path);
    chdir(to_path.c_str());
    // cout << "chdir status: " << chdir(to_path.c_str());
    control();
    printf("\033[2J"); // clear screen;
    printf("\033[1;1f");// set cursor to top;
    print();
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);

    printf("\033[%d;1f", w.ws_row-2);// set cursor to bottom;
    goto_flag = true;
    // fflush(stdout);
    // setnew();

}


bool search(string currpath, string filename, string isdir){
    // cout << "Curr directory : " << currpath << endl;
    DIR* dir_ptr = opendir(currpath.c_str());
    struct dirent* dir_ent_ptr;

    dir_ent_ptr = readdir(dir_ptr);

    struct stat filestats;
    bool curans = false;
    while(dir_ent_ptr){
        string currname = string(dir_ent_ptr->d_name);
        // cout << "curr name" << currname << endl;
        if(currname==".." || currname=="."){
            dir_ent_ptr = readdir(dir_ptr);
            continue;  
        } 
        string fullpath = currpath + "/" + currname;
        stat(fullpath.c_str(), &filestats);
        if(currname==filename){
            if(S_ISDIR(filestats.st_mode) && (isdir=="1")){
                return true;
            }
            else if(!(S_ISDIR(filestats.st_mode)) && (isdir=="0")){
                return true;
            }
        }
        if(S_ISDIR(filestats.st_mode)){
            curans = search(currpath + "/" + currname, filename, isdir);
            if(curans) return true;
        }
        dir_ent_ptr = readdir(dir_ptr);
    }
    return false;

}

void delete_file(string path){
    remove(path.c_str());
}

void execute(string str){
    vector<string> cmd_arr;
    parse_cmd(str, cmd_arr);

    string op = cmd_arr[0];

    if(op=="copy"){
        string dest = cmd_arr[cmd_arr.size()-1];
        // FILE* srcf=NULL;
        // FILE* destf=NULL;
        for(int i=1; i<cmd_arr.size()-1; i++){
            
            string destpath = dest;
            destpath.push_back('/');            
            destpath += cmd_arr[i];
            copy_file(cmd_arr[i], destpath);
            // destf = fopen(destpath.c_str(),"w");   
            // if(!destf){
            //     cout << "error opening file " << endl;
            //     exit(0);
            // }
            // srcf = fopen(cmd_arr[i].c_str(),"r");
            // if(!srcf){
            //     cout << "error opening file " << endl;
            //     exit(0);
            // }
            // char c;
            // c = fgetc(srcf); 
            // while (c != EOF){
            //     fputc(c, destf); 
            //     c = fgetc(srcf); 
            // } 
            // fclose(srcf);
            // fclose(destf);
        }
    }
    else if(op=="move"){
        string dest = cmd_arr[cmd_arr.size()-1];
        FILE* srcf=NULL;
        FILE* destf=NULL;
        for(int i=1; i<cmd_arr.size()-1; i++){
            
            string destpath = dest;
            destpath.push_back('/');
            destpath += cmd_arr[i];
            destf = fopen(destpath.c_str(),"w");   
            if(!destf){
                cout << "error opening file " << endl;
                exit(0);
            }
            srcf = fopen(cmd_arr[i].c_str(),"r");
            if(!destf){
                cout << "error opening file " << endl;
                exit(0);
            }
            char c;
            c = fgetc(srcf); 
            while (c != EOF){
                fputc(c, destf); 
                c = fgetc(srcf); 
            } 
            fclose(srcf);
            remove(cmd_arr[i].c_str());
            fclose(destf);
        }
    }
    else if(op=="rename"){
        struct stat filestat;        
        string dest = cmd_arr[cmd_arr.size()-1];
        FILE* srcf=NULL;
        FILE* destf=NULL;
        string destpath = dest;
        // destpath.push_back('/');
        // destpath += cmd_arr[i];
        // stat(cmd_arr[1].c_str(), &filestat);
        // if(filestat.st_mode & S_IFDIR){
        //     cout << " DIRECTORY !!" << endl;
        //     return;
        // }

        destf = fopen(cmd_arr[2].c_str(),"w");   
        if(!destf){
            cout << "error opening file " << cmd_arr[2].c_str()<< endl;
            exit(0);
        }
        srcf = fopen(cmd_arr[1].c_str(),"r");
        if(!destf){
            cout << "error opening file " << cmd_arr[1].c_str() <<endl;
            exit(0);
        }
        char c;
        c = fgetc(srcf); 
        while (c != EOF){
            fputc(c, destf); 
            c = fgetc(srcf); 
        } 
        fclose(srcf);
        remove(cmd_arr[1].c_str());
        fclose(destf);
    }
    else if(op=="create_file"){
        create_file(cmd_arr[1], cmd_arr[2]);
    }
    else if(op=="create_dir"){
        string dest_path = string(cmd_arr[2]) + "/" + string(cmd_arr[1]);
        create_dir(dest_path);
    }
    else if(op=="copy_dir"){
        // string dest_path = string(cmd_arr[1]) + string(cmd_arr[2]);
        create_dir(string(cmd_arr[2]));
        copy_dir(cmd_arr[1], cmd_arr[2]);
    }
    else if(op=="remove_empty"){
        remove_empty(cmd_arr[1]);
    }
    else if(op=="delete_dir"){
        delete_dir(cmd_arr[1]);
    }
    else if(op=="move_dir"){
        move_dir(cmd_arr[1], cmd_arr[2]);
    }
    else if(op=="go_to"){
        go_to(cmd_arr[1]);
    }
    else if(op=="search"){
        char* currpath = new char[PATH_MAX];
        getcwd(currpath, PATH_MAX);
        // cout << "is present : " << search(string(currpath),cmd_arr[1], cmd_arr[2]);
        if(search(string(currpath),cmd_arr[1], cmd_arr[2])){
            cout << "True";
            // delay(3000);
        }
        else{
            cout << "False";
        } 
    }
    else if(op=="delete_file"){
        delete_file(cmd_arr[1]);
    }
}

void navigate(){
    struct stat filestat;
    print();
    int row, col;
    getCursorPosition(&row, &col);
    char c,d,e;

    // st1.push(path);
    while(c!='q'){
        // cin >> c;
        c = cin.get();
        if(c==27){
            d=cin.get();
            if(d==91){
                // cin >> e;
                e=cin.get();
                switch(e){
                    case 65:
                        //up
                        if(dir_cnt-1){
                            printf("\033[1A");
                            --dir_cnt;
                            --cur_dir;
                        }
                        break;
                    case 66:
                        //down
                        if(dir_cnt < cnt){
                            ++dir_cnt;
                            ++cur_dir;
                            printf("\033[1B");
                        }
                        break;
                    case 67:{

                        //right
                        // char tmp[PATH_MAX]={'\0'};
                        if(!st2.empty()){
                            char* tmp = new char[PATH_MAX];
                            int i=0; 
                            for(i=0; i<PATH_MAX; i++){
                                tmp[i] = path[i];
                            }
                            tmp[i] = '\0';
                            st1.push(tmp);
                            chdir(st2.top());
                            st2.pop();
                            control();
                            printf("\033[2J"); // clear screen;
                            printf("\033[1;1f");// set cursor to top;
                            print();
                            getCursorPosition(&row,&col);
                        }
                        
                        // printf("\033[1C");
                        break;
                    }
                    case 68:{
                        // left
                        // char tmp[PATH_MAX]={'\0'};
                        if(!st1.empty()){
                            char* tmp = new char[PATH_MAX];
                            int i=0; 
                            for(i=0; i<PATH_MAX; i++){
                                tmp[i] = path[i];
                            }
                            tmp[i] = '\0';
                            st2.push(tmp);
                            chdir(st1.top());
                            st1.pop();
                            control();
                            printf("\033[2J"); // clear screen;
                            printf("\033[1;1f");// set cursor to top;
                            print();
                            getCursorPosition(&row,&col);
                            // printf("\033[1D");
                        }
                        break;   
                    }
                        
                }
            }
        }
        else if(c==13 || c==10){
            stat(dir_struct_arr[cur_dir]->d_name,&filestat);
            if(!S_ISDIR(filestat.st_mode)){
                run();
                continue;
            }
            // printf("\033[%d;1f",row+2);
            // cout << "path " << path << endl;
            // printf("\033[2J"); // clear screen;
            // printf("path :\n");
            char* tmp = new char[PATH_MAX];
            int i=0; 
            for(i=0; i<PATH_MAX; i++){
                tmp[i] = path[i];
            }
            tmp[i] = '\0';
            st1.push(tmp);
            // char prev[] = "..";
            // if(strcmp(prev,dir_struct_arr[cur_dir]->d_name)==0){
            //     st2.push(st1.top());
            //     st1.pop();
            // }
            i=0;
            while(path[i]!='\0'){
                ++i;
            }
            // cout << "i " << i << endl;
            path[i] = '/';
            ++i;
            int j=0;
            while(j<dir_arr[cur_dir].size()){
                path[i] = dir_arr[cur_dir][j];
                ++j;
                ++i;
            }
            chdir(path);
            control();
            printf("\033[2J"); // clear screen;
            printf("\033[1;1f");// set cursor to top;
            print();
            // cout << st1.top() << endl;
            getCursorPosition(&row,&col);
            // printf("\033[%d;1f",row+1);
            // cout << "path : " << path << endl;
        }
        else if(c==104){
            // home key
            char* tmp = new char[PATH_MAX];
            int i=0; 
            for(i=0; i<PATH_MAX; i++){
                tmp[i] = path[i];
            }
            tmp[i] = '\0';
            st1.push(tmp);
            chdir(home_path);
            control();
            printf("\033[2J"); // clear screen;
            printf("\033[1;1f");// set cursor to top;
            print();
            // cout << st1.top() << endl;
            getCursorPosition(&row,&col);
        }
        else if(c==58){
            // colon key
            getCursorPosition(&sx, &sy);
            struct winsize w;
            ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);

            printf("\033[%d;1f", w.ws_row-2);// set cursor to bottom;
            
            // char cmdinp;
            // cmdinp = cin.get();
            setold();
            string str = "";
            char ch;

            while ((ch = std::cin.get()) != 27) {
                if(ch==13 || ch==10){
                    execute(str);
                    // <ESC>[2K
                    
                    str = "";
                }
                else str += ch;
            }
            // if(gotoflag)cout << "after goto :" << endl;
            // if(!gotoflag)fflush(stdout);
            printf("\033[%d;1f", w.ws_row-2);// set cursor to bottom;
            printf("\033[J");// set cursor to bottom;
            fflush(stdout);
            // if(!gotoflag)setnew();
            setnew();
            ///////////////////
            // if(!gotoflag) printf("\033[%d;%df",sx,sy);
            if(goto_flag){
                printf("\033[%d;%df",dir_cnt,1);
                goto_flag = false;
            } 
            else printf("\033[%d;%df",sx,sy);
            // gotoflag=false;
        }
        else if(c==127){
            // cout << endl << "backspace pressed" << endl;
            char* tmp = new char[PATH_MAX];
            int i=0; 
            for(i=0; i<PATH_MAX; i++){
                tmp[i] = path[i];
            }
            tmp[i] = '\0';
            st2.push(tmp);
            string back = "..";
            chdir(back.c_str());
            // st1.pop();
            control();
            printf("\033[2J"); // clear screen;
            printf("\033[1;1f");// set cursor to top;
            print();
            getCursorPosition(&row,&col);
            // printf("\033[1D");
        }
        
    }
}


int main(){
    
    // vector<string> dir_arr;

    tcgetattr(0, &oldattr); // get the original terminal attributes.
    tcgetattr(0, &newattr); // getting the old attributes for modifying.
    atexit(setold); // set the old attributes on exit.
    newattr.c_lflag &= ~(ECHO | ICANON); // turn off echo and canonical mode.
    newattr.c_cc[VMIN] = 1;
    newattr.c_cc[VTIME] = 0;
    tcsetattr (STDIN_FILENO, TCSADRAIN, &newattr);
    int row, col;

    // DIR* dir_ptr = opendir(".");

    // struct dirent* dir_ent_ptr;

    // if(!dir_ptr){
    //     cout << "Error opening directory" << endl;
    // }
    // int dir_cnt=0;
    
    

    // dir_ent_ptr = readdir(dir_ptr);
    // while(dir_ent_ptr){
    //     ++dir_cnt;
    //     // cout << dir_ent_ptr->d_name << endl;
    //     dir_arr.push_back(dir_ent_ptr->d_name);
    //     dir_ent_ptr = readdir(dir_ptr);
    // }

    // navigate();
    // return 0;
    // // for(auto it : dir_arr) cout << it << endl;

    // char c,d,e;
    // c='a';
    // printf("\033[1A");
    // getCursorPosition(&row, &col); // get current cursor position.
    // int cnt = dir_cnt;
    
    // int cur_dir = dir_arr.size()-1;

    // char* path = new char[PATH_MAX];
    // getcwd(path,PATH_MAX);

    // cout << "path : " << path << endl;

    // while(c!='q'){
    //     // cin >> c;
    //     c = cin.get();
    //     if(c==27){
    //         cin >> d;
    //         if(d==91){
    //             cin >> e;
    //             switch(e){
    //                 case 65:
    //                     if(dir_cnt-1){
    //                         printf("\033[1A");
    //                         --dir_cnt;
    //                         --cur_dir;
    //                     }
    //                     break;
    //                 case 66:
    //                     if(dir_cnt < cnt){
    //                         ++dir_cnt;
    //                         ++cur_dir;
    //                         printf("\033[1B");
    //                     }
    //                     break;
    //                 case 67:
    //                     printf("\033[1C");
    //                     break;
    //                 case 68:
    //                     printf("\033[1D");
    //                     break;
    //             }
    //         }
    //     }
    //     else if(c==13 || c==10){
    //         printf("\033[2J");
    //         printf("\033[1;1f");
    //     }
    // }


    
    // cout << cur_dir;
    home_path = new char[PATH_MAX];
    getcwd(home_path, PATH_MAX);
    control();
    navigate();
    // printf("\033[%d;1f",row+1);
    // while(!st1.empty()){
    //     cout << st1.top() << endl;
    //     st1.pop();
    // }

    return 0;
}